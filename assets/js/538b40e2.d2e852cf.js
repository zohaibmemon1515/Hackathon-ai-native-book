"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[380],{5343:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"hardware-edge-ai/chapter3/lesson1","title":"Humanoid Robot Morphology and Kinematics","description":"Learning Objectives","source":"@site/docs/hardware-edge-ai/chapter3/lesson1.md","sourceDirName":"hardware-edge-ai/chapter3","slug":"/hardware-edge-ai/chapter3/lesson1","permalink":"/Hackathon-ai-native-book/book/docs/hardware-edge-ai/chapter3/lesson1","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/hardware-edge-ai/chapter3/lesson1.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Humanoid Robot Morphology and Kinematics","sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Humanoid Robotics Hardware & Design","permalink":"/Hackathon-ai-native-book/book/docs/category/humanoid-robotics-hardware--design"},"next":{"title":"Whole-Body Control for Humanoid Robots","permalink":"/Hackathon-ai-native-book/book/docs/hardware-edge-ai/chapter3/lesson2"}}');var t=i(4848),s=i(8453);const r={title:"Humanoid Robot Morphology and Kinematics",sidebar_position:1},a=void 0,l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Concept Explanation",id:"concept-explanation",level:2},{value:"Real-World Examples",id:"real-world-examples",level:2},{value:"Mathematical or technical breakdown",id:"mathematical-or-technical-breakdown",level:2},{value:"Mini-Project",id:"mini-project",level:2},{value:"Summary",id:"summary",level:2},{value:"APA-style references",id:"apa-style-references",level:2}];function d(e){const n={code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Understand the basic morphological structure of humanoid robots."}),"\n",(0,t.jsx)(n.li,{children:"Learn about forward and inverse kinematics as applied to humanoid limbs."}),"\n",(0,t.jsx)(n.li,{children:"Identify the challenges of multi-joint kinematics in complex robotic systems."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"concept-explanation",children:"Concept Explanation"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Humanoid robots"})," are designed to mimic the human form, providing them with the ability to interact with human-centric environments and tools. Their complex morphology, with multiple limbs and many degrees of freedom (DoF), presents significant challenges in ",(0,t.jsx)(n.strong,{children:"kinematics"}),", which deals with the geometry of motion."]}),"\n",(0,t.jsx)(n.p,{children:"Key concepts in humanoid robot kinematics:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Degrees of Freedom (DoF)"}),": The number of independent parameters that define the configuration of a robotic system. Humanoid robots typically have many DoF (e.g., 20-60+)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Forward Kinematics (FK)"}),": Calculates the position and orientation of the end-effector (e.g., hand, foot) given the joint angles of the robot. This is a straightforward calculation."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Inverse Kinematics (IK)"}),": Calculates the joint angles required to achieve a desired position and orientation of the end-effector. This is a more complex, often non-linear, and sometimes ambiguous problem."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"real-world-examples",children:"Real-World Examples"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A humanoid robot performing a complex dance move, requiring precise control of many joint angles for balance and expressiveness."}),"\n",(0,t.jsx)(n.li,{children:"A humanoid robot reaching for an object on a table, where IK is used to determine the necessary joint configurations for its arm."}),"\n",(0,t.jsx)(n.li,{children:"Boston Dynamics' Atlas robot demonstrating dynamic locomotion and manipulation, relying on sophisticated kinematic and dynamic models."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"mathematical-or-technical-breakdown",children:"Mathematical or technical breakdown"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Forward Kinematics"})," can be computed using transformation matrices (e.g., Denavit-Hartenberg parameters) that describe the relative pose between adjacent links. For a chain of ",(0,t.jsx)(n.code,{children:"n"})," joints, the end-effector pose ",(0,t.jsx)(n.code,{children:"T_n"})," is the product of individual link transformations: ",(0,t.jsx)(n.code,{children:"T_n = T_01 * T_12 * ... * T_(n-1)n"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Inverse Kinematics"})," is generally solved using iterative numerical methods (e.g., Jacobian pseudo-inverse method, gradient descent) or analytical solutions for simpler kinematic chains. The Jacobian matrix relates joint velocities to end-effector velocities: ",(0,t.jsx)(n.code,{children:"v_e = J(q) * q_dot"}),", where ",(0,t.jsx)(n.code,{children:"v_e"})," is end-effector velocity, ",(0,t.jsx)(n.code,{children:"q"})," is joint angles, and ",(0,t.jsx)(n.code,{children:"q_dot"})," is joint velocities."]}),"\n",(0,t.jsx)(n.p,{children:"Challenges in IK for humanoids:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Redundancy"}),": Many DoF means multiple joint configurations can achieve the same end-effector pose."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Joint Limits"}),": Physical constraints on how far joints can rotate."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Singularities"}),": Configurations where the robot loses DoF, making IK difficult or impossible to solve."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"mini-project",children:"Mini-Project"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Conceptualize Humanoid Arm Kinematics"}),":"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Draw a simplified 3-DoF robotic arm (e.g., shoulder pitch, shoulder roll, elbow pitch)."}),"\n",(0,t.jsxs)(n.li,{children:["Given a desired (x, y, z) position for the end-effector, conceptually describe how you would:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Set up the forward kinematics equations to find the end-effector position given joint angles."}),"\n",(0,t.jsx)(n.li,{children:"Outline an iterative approach to solve for the joint angles using inverse kinematics to reach a specific target position."}),"\n",(0,t.jsx)(n.li,{children:"Discuss potential issues like unreachable targets or multiple solutions."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"Humanoid robot morphology and kinematics are foundational for understanding their motion capabilities. Forward kinematics describes motion from joint angles to end-effector pose, while inverse kinematics solves the more complex problem of finding joint angles for a desired end-effector pose, both critical for controlling these complex systems."}),"\n",(0,t.jsx)(n.h2,{id:"apa-style-references",children:"APA-style references"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Siciliano, B., & Khatib, O. (Eds.). (2016). ",(0,t.jsx)(n.em,{children:"Springer Handbook of Robotics"})," (2nd ed.). Springer."]}),"\n",(0,t.jsxs)(n.li,{children:["Spong, M. W., Hutchinson, S., & Vidyasagar, M. (2020). ",(0,t.jsx)(n.em,{children:"Robot Modeling and Control"})," (2nd ed.). Wiley."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var o=i(6540);const t={},s=o.createContext(t);function r(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);